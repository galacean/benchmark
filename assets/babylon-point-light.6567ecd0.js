import"./modulepreload-polyfill.c7c6310f.js";import{L as T,V as z,P as b,b as W,T as H,C as X,G as k,M as q,c as K,d as j,e as Q,f as J,g as _,h as $,i as ee,j as te,k as se,l as ne,m as oe,n as ae,o as ie,p as re,q as ce,r as he,s as le,t as fe,u as de,v as xe,w as Ae,x as ue,y as ye,z as ge,A as Be,B as ve,F as Oe,H as me,I as pe,E as De,S as be,J as Ce,K as U,N as we,O as Ve,a as Fe}from"./splatFileLoader.eebe693f.js";class O{constructor(t=0,e=0){this.x=t,this.y=e,t!==Math.floor(t)&&T.Warn("x is not an integer, floor(x) used"),e!==Math.floor(e)&&T.Warn("y is not an integer, floor(y) used")}clone(){return new O(this.x,this.y)}rotate60About(t){const e=this.x;return this.x=t.x+t.y-this.y,this.y=e+this.y-t.x,this}rotateNeg60About(t){const e=this.x;return this.x=e+this.y-t.y,this.y=t.x+t.y-e,this}rotate120(t,e){t!==Math.floor(t)&&T.Warn("m not an integer only floor(m) used"),e!==Math.floor(e)&&T.Warn("n not an integer only floor(n) used");const n=this.x;return this.x=t-n-this.y,this.y=e+n,this}rotateNeg120(t,e){t!==Math.floor(t)&&T.Warn("m is not an integer, floor(m) used"),e!==Math.floor(e)&&T.Warn("n is not an integer,   floor(n) used");const n=this.x;return this.x=this.y-e,this.y=t+e-n-this.y,this}toCartesianOrigin(t,e){const n=z.Zero();return n.x=t.x+2*this.x*e+this.y*e,n.y=t.y+Math.sqrt(3)*this.y*e,n}static Zero(){return new O(0,0)}}class Y{constructor(){this.cartesian=[],this.vertices=[],this.max=[],this.min=[],this.closestTo=[],this.innerFacets=[],this.isoVecsABOB=[],this.isoVecsOBOA=[],this.isoVecsBAOA=[],this.vertexTypes=[],this.IDATA=new Z("icosahedron","Regular",[[0,b,-1],[-b,1,0],[-1,0,-b],[1,0,-b],[b,1,0],[0,b,1],[-1,0,b],[-b,-1,0],[0,-b,-1],[b,-1,0],[1,0,b],[0,-b,1]],[[0,2,1],[0,3,2],[0,4,3],[0,5,4],[0,1,5],[7,6,1],[8,7,2],[9,8,3],[10,9,4],[6,10,5],[2,7,1],[3,8,2],[4,9,3],[5,10,4],[1,6,5],[11,6,7],[11,7,8],[11,8,9],[11,9,10],[11,10,6]])}setIndices(){let t=12;const e={},n=this.m,s=this.n;let i=n,o=1,r=0;s!==0&&(i=W.HCF(n,s)),o=n/i,r=s/i;let c,f,y,B,x;const F=O.Zero(),A=new O(n,s),g=new O(-s,n+s),u=O.Zero(),D=O.Zero(),v=O.Zero();let C=[],l,a,h,w;const M=[],d=this.vertByDist,I=(V,m,S,N)=>{l=V+"|"+S,a=m+"|"+N,l in e||a in e?l in e&&!(a in e)?e[a]=e[l]:a in e&&!(l in e)&&(e[l]=e[a]):(e[l]=t,e[a]=t,t++),d[S][0]>2?M[e[l]]=[-d[S][0],d[S][1],e[l]]:M[e[l]]=[C[d[S][0]],d[S][1],e[l]]};this.IDATA.edgematch=[[1,"B"],[2,"B"],[3,"B"],[4,"B"],[0,"B"],[10,"O",14,"A"],[11,"O",10,"A"],[12,"O",11,"A"],[13,"O",12,"A"],[14,"O",13,"A"],[0,"O"],[1,"O"],[2,"O"],[3,"O"],[4,"O"],[19,"B",5,"A"],[15,"B",6,"A"],[16,"B",7,"A"],[17,"B",8,"A"],[18,"B",9,"A"]];for(let V=0;V<20;V++){if(C=this.IDATA.face[V],y=C[2],B=C[1],x=C[0],h=F.x+"|"+F.y,l=V+"|"+h,l in e||(e[l]=y,M[y]=[C[d[h][0]],d[h][1]]),h=A.x+"|"+A.y,l=V+"|"+h,l in e||(e[l]=B,M[B]=[C[d[h][0]],d[h][1]]),h=g.x+"|"+g.y,l=V+"|"+h,l in e||(e[l]=x,M[x]=[C[d[h][0]],d[h][1]]),c=this.IDATA.edgematch[V][0],f=this.IDATA.edgematch[V][1],f==="B")for(let m=1;m<i;m++)D.x=n-m*(o+r),D.y=s+m*o,v.x=-m*r,v.y=m*(o+r),h=D.x+"|"+D.y,w=v.x+"|"+v.y,I(V,c,h,w);if(f==="O")for(let m=1;m<i;m++)v.x=-m*r,v.y=m*(o+r),u.x=m*o,u.y=m*r,h=v.x+"|"+v.y,w=u.x+"|"+u.y,I(V,c,h,w);if(c=this.IDATA.edgematch[V][2],f=this.IDATA.edgematch[V][3],f&&f==="A")for(let m=1;m<i;m++)u.x=m*o,u.y=m*r,D.x=n-(i-m)*(o+r),D.y=s+(i-m)*o,h=u.x+"|"+u.y,w=D.x+"|"+D.y,I(V,c,h,w);for(let m=0;m<this.vertices.length;m++)h=this.vertices[m].x+"|"+this.vertices[m].y,l=V+"|"+h,l in e||(e[l]=t++,d[h][0]>2?M[e[l]]=[-d[h][0],d[h][1],e[l]]:M[e[l]]=[C[d[h][0]],d[h][1],e[l]])}this.closestTo=M,this.vecToidx=e}calcCoeffs(){const t=this.m,e=this.n,n=Math.sqrt(3)/3,s=t*t+e*e+t*e;this.coau=(t+e)/s,this.cobu=-e/s,this.coav=-n*(t-e)/s,this.cobv=n*(2*t+e)/s}createInnerFacets(){const t=this.m,e=this.n;for(let n=0;n<e+t+1;n++)for(let s=this.min[n];s<this.max[n]+1;s++)s<this.max[n]&&s<this.max[n+1]+1&&this.innerFacets.push(["|"+s+"|"+n,"|"+s+"|"+(n+1),"|"+(s+1)+"|"+n]),n>0&&s<this.max[n-1]&&s+1<this.max[n]+1&&this.innerFacets.push(["|"+s+"|"+n,"|"+(s+1)+"|"+n,"|"+(s+1)+"|"+(n-1)])}edgeVecsABOB(){const t=this.m,e=this.n,n=new O(-e,t+e);for(let s=1;s<t+e;s++){const i=new O(this.min[s],s),o=new O(this.min[s-1],s-1),r=new O(this.min[s+1],s+1),c=i.clone(),f=o.clone(),y=r.clone();c.rotate60About(n),f.rotate60About(n),y.rotate60About(n);const B=new O(this.max[c.y],c.y),x=new O(this.max[c.y-1],c.y-1),F=new O(this.max[c.y-1]-1,c.y-1);(c.x!==B.x||c.y!==B.y)&&(c.x!==x.x?(this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([i,x,F]),this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([i,F,B])):c.y===y.y?(this.vertexTypes.push([1,1,0]),this.isoVecsABOB.push([i,o,x]),this.vertexTypes.push([1,0,1]),this.isoVecsABOB.push([i,x,r])):(this.vertexTypes.push([1,1,0]),this.isoVecsABOB.push([i,o,x]),this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([i,x,B])))}}mapABOBtoOBOA(){const t=new O(0,0);for(let e=0;e<this.isoVecsABOB.length;e++){const n=[];for(let s=0;s<3;s++)t.x=this.isoVecsABOB[e][s].x,t.y=this.isoVecsABOB[e][s].y,this.vertexTypes[e][s]===0&&t.rotateNeg120(this.m,this.n),n.push(t.clone());this.isoVecsOBOA.push(n)}}mapABOBtoBAOA(){const t=new O(0,0);for(let e=0;e<this.isoVecsABOB.length;e++){const n=[];for(let s=0;s<3;s++)t.x=this.isoVecsABOB[e][s].x,t.y=this.isoVecsABOB[e][s].y,this.vertexTypes[e][s]===1&&t.rotate120(this.m,this.n),n.push(t.clone());this.isoVecsBAOA.push(n)}}MapToFace(t,e){const n=this.IDATA.face[t],s=n[2],i=n[1],o=n[0],r=z.FromArray(this.IDATA.vertex[s]),c=z.FromArray(this.IDATA.vertex[i]),f=z.FromArray(this.IDATA.vertex[o]),y=c.subtract(r),B=f.subtract(r),x=y.scale(this.coau).add(B.scale(this.cobu)),F=y.scale(this.coav).add(B.scale(this.cobv));let A,g=H.Vector3[0];for(let u=0;u<this.cartesian.length;u++)g=x.scale(this.cartesian[u].x).add(F.scale(this.cartesian[u].y)).add(r),g.x,g.y,g.z,A=t+"|"+this.vertices[u].x+"|"+this.vertices[u].y,e.vertex[this.vecToidx[A]]=[g.x,g.y,g.z]}build(t,e){const n=[],s=O.Zero(),i=new O(t,e),o=new O(-e,t+e);n.push(s,i,o);for(let a=e;a<t+1;a++)for(let h=0;h<t+1-a;h++)n.push(new O(h,a));if(e>0){const a=W.HCF(t,e),h=t/a,w=e/a;for(let d=1;d<a;d++)n.push(new O(d*h,d*w)),n.push(new O(-d*w,d*(h+w))),n.push(new O(t-d*(h+w),e+d*h));const M=t/e;for(let d=1;d<e;d++)for(let I=0;I<d*M;I++)n.push(new O(I,d)),n.push(new O(I,d).rotate120(t,e)),n.push(new O(I,d).rotateNeg120(t,e))}n.sort((a,h)=>a.x-h.x),n.sort((a,h)=>a.y-h.y);const r=new Array(t+e+1),c=new Array(t+e+1);for(let a=0;a<r.length;a++)r[a]=1/0,c[a]=-1/0;let f=0,y=0;const B=n.length;for(let a=0;a<B;a++)y=n[a].x,f=n[a].y,r[f]=Math.min(y,r[f]),c[f]=Math.max(y,c[f]);const x=(a,h)=>{const w=a.clone();return h==="A"&&w.rotateNeg120(t,e),h==="B"&&w.rotate120(t,e),w.x<0?w.y:w.x+w.y},F=[],A=[],g=[],u=[],D={},v=[];let C=-1,l=-1;for(let a=0;a<B;a++)F[a]=n[a].toCartesianOrigin(new O(0,0),.5),A[a]=x(n[a],"O"),g[a]=x(n[a],"A"),u[a]=x(n[a],"B"),A[a]===g[a]&&g[a]===u[a]?(C=3,l=A[a]):A[a]===g[a]?(C=4,l=A[a]):g[a]===u[a]?(C=5,l=g[a]):u[a]===A[a]&&(C=6,l=A[a]),A[a]<g[a]&&A[a]<u[a]&&(C=2,l=A[a]),g[a]<A[a]&&g[a]<u[a]&&(C=1,l=g[a]),u[a]<g[a]&&u[a]<A[a]&&(C=0,l=u[a]),v.push([C,l,n[a].x,n[a].y]);v.sort((a,h)=>a[2]-h[2]),v.sort((a,h)=>a[3]-h[3]),v.sort((a,h)=>a[1]-h[1]),v.sort((a,h)=>a[0]-h[0]);for(let a=0;a<v.length;a++)D[v[a][2]+"|"+v[a][3]]=[v[a][0],v[a][1],a];return this.m=t,this.n=e,this.vertices=n,this.vertByDist=D,this.cartesian=F,this.min=r,this.max=c,this}}class Z{constructor(t,e,n,s){this.name=t,this.category=e,this.vertex=n,this.face=s}}class G extends Z{innerToData(t,e){for(let n=0;n<e.innerFacets.length;n++)this.face.push(e.innerFacets[n].map(s=>e.vecToidx[t+s]))}mapABOBtoDATA(t,e){const n=e.IDATA.edgematch[t][0];for(let s=0;s<e.isoVecsABOB.length;s++){const i=[];for(let o=0;o<3;o++)e.vertexTypes[s][o]===0?i.push(t+"|"+e.isoVecsABOB[s][o].x+"|"+e.isoVecsABOB[s][o].y):i.push(n+"|"+e.isoVecsABOB[s][o].x+"|"+e.isoVecsABOB[s][o].y);this.face.push([e.vecToidx[i[0]],e.vecToidx[i[1]],e.vecToidx[i[2]]])}}mapOBOAtoDATA(t,e){const n=e.IDATA.edgematch[t][0];for(let s=0;s<e.isoVecsOBOA.length;s++){const i=[];for(let o=0;o<3;o++)e.vertexTypes[s][o]===1?i.push(t+"|"+e.isoVecsOBOA[s][o].x+"|"+e.isoVecsOBOA[s][o].y):i.push(n+"|"+e.isoVecsOBOA[s][o].x+"|"+e.isoVecsOBOA[s][o].y);this.face.push([e.vecToidx[i[0]],e.vecToidx[i[1]],e.vecToidx[i[2]]])}}mapBAOAtoDATA(t,e){const n=e.IDATA.edgematch[t][2];for(let s=0;s<e.isoVecsBAOA.length;s++){const i=[];for(let o=0;o<3;o++)e.vertexTypes[s][o]===1?i.push(t+"|"+e.isoVecsBAOA[s][o].x+"|"+e.isoVecsBAOA[s][o].y):i.push(n+"|"+e.isoVecsBAOA[s][o].x+"|"+e.isoVecsBAOA[s][o].y);this.face.push([e.vecToidx[i[0]],e.vecToidx[i[1]],e.vecToidx[i[2]]])}}orderData(t){const e=[];for(let o=0;o<13;o++)e[o]=[];const n=t.closestTo;for(let o=0;o<n.length;o++)n[o][0]>-1?n[o][1]>0&&e[n[o][0]].push([o,n[o][1]]):e[12].push([o,n[o][0]]);const s=[];for(let o=0;o<12;o++)s[o]=o;let i=12;for(let o=0;o<12;o++){e[o].sort((r,c)=>r[1]-c[1]);for(let r=0;r<e[o].length;r++)s[e[o][r][0]]=i++}for(let o=0;o<e[12].length;o++)s[e[12][o][0]]=i++;for(let o=0;o<this.vertex.length;o++)this.vertex[o].push(s[o]);this.vertex.sort((o,r)=>o[3]-r[3]);for(let o=0;o<this.vertex.length;o++)this.vertex[o].pop();for(let o=0;o<this.face.length;o++)for(let r=0;r<this.face[o].length;r++)this.face[o][r]=s[this.face[o][r]];this.sharedNodes=e[12].length,this.poleNodes=this.vertex.length-this.sharedNodes}setOrder(t,e){const n=[],s=[];let i=e.pop();s.push(i);let o=this.face[i].indexOf(t);o=(o+2)%3;let r=this.face[i][o];n.push(r);let c=0;for(;e.length>0;)i=e[c],this.face[i].indexOf(r)>-1?(o=(this.face[i].indexOf(r)+1)%3,r=this.face[i][o],n.push(r),s.push(i),e.splice(c,1),c=0):c++;return this.adjacentFaces.push(n),s}toGoldbergPolyhedronData(){const t=new Z("GeoDual","Goldberg",[],[]);t.name="GD dual";const e=this.vertex.length,n=new Array(e);for(let f=0;f<e;f++)n[f]=[];for(let f=0;f<this.face.length;f++)for(let y=0;y<3;y++)n[this.face[f][y]].push(f);let s=0,i=0,o=0,r=[],c=[];this.adjacentFaces=[];for(let f=0;f<n.length;f++)t.face[f]=this.setOrder(f,n[f].concat([])),n[f].forEach(y=>{s=0,i=0,o=0,r=this.face[y];for(let B=0;B<3;B++)c=this.vertex[r[B]],s+=c[0],i+=c[1],o+=c[2];t.vertex[y]=[s/3,i/3,o/3]});return t}static BuildGeodesicData(t){const e=new G("Geodesic-m-n","Geodesic",[[0,b,-1],[-b,1,0],[-1,0,-b],[1,0,-b],[b,1,0],[0,b,1],[-1,0,b],[-b,-1,0],[0,-b,-1],[b,-1,0],[1,0,b],[0,-b,1]],[]);t.setIndices(),t.calcCoeffs(),t.createInnerFacets(),t.edgeVecsABOB(),t.mapABOBtoOBOA(),t.mapABOBtoBAOA();for(let s=0;s<t.IDATA.face.length;s++)t.MapToFace(s,e),e.innerToData(s,t),t.IDATA.edgematch[s][1]==="B"&&e.mapABOBtoDATA(s,t),t.IDATA.edgematch[s][1]==="O"&&e.mapOBOAtoDATA(s,t),t.IDATA.edgematch[s][3]==="A"&&e.mapBAOAtoDATA(s,t);e.orderData(t);const n=1;return e.vertex=e.vertex.map(function(s){const i=s[0],o=s[1],r=s[2],c=Math.sqrt(i*i+o*o+r*r);return s[0]*=n/c,s[1]*=n/c,s[2]*=n/c,s}),e}}function ze(p,t,e=null){let n=t.m||1;n!==Math.floor(n)&&T.Warn("m not an integer only floor(m) used");let s=t.n||0;if(s!==Math.floor(s)&&T.Warn("n not an integer only floor(n) used"),s>n){const f=s;s=n,n=f,T.Warn("n > m therefore m and n swapped")}const i=new Y;i.build(n,s);const r={custom:G.BuildGeodesicData(i),size:t.size,sizeX:t.sizeX,sizeY:t.sizeY,sizeZ:t.sizeZ,faceUV:t.faceUV,faceColors:t.faceColors,flat:t.flat,updatable:t.updatable,sideOrientation:t.sideOrientation,frontUVs:t.frontUVs,backUVs:t.backUVs};return X(p,r,e)}function Ie(p,t){const e=p.size,n=p.sizeX||e||1,s=p.sizeY||e||1,i=p.sizeZ||e||1,o=p.sideOrientation===0?0:p.sideOrientation||j.DEFAULTSIDE,r=[],c=[],f=[],y=[];let B=1/0,x=-1/0,F=1/0,A=-1/0;for(let D=0;D<t.vertex.length;D++)B=Math.min(B,t.vertex[D][0]*n),x=Math.max(x,t.vertex[D][0]*n),F=Math.min(F,t.vertex[D][1]*s),A=Math.max(A,t.vertex[D][1]*s);let g=0;for(let D=0;D<t.face.length;D++){const v=t.face[D],C=z.FromArray(t.vertex[v[0]]),l=z.FromArray(t.vertex[v[2]]),a=z.FromArray(t.vertex[v[1]]),h=l.subtract(C),w=a.subtract(C),M=z.Cross(w,h).normalize();for(let d=0;d<v.length;d++){f.push(M.x,M.y,M.z);const I=t.vertex[v[d]];r.push(I[0]*n,I[1]*s,I[2]*i);const V=(I[1]*s-F)/(A-F);y.push((I[0]*n-B)/(x-B),Q.UseOpenGLOrientationForUV?1-V:V)}for(let d=0;d<v.length-2;d++)c.push(g,g+d+2,g+d+1);g+=v.length}j._ComputeSides(o,r,c,f,y);const u=new j;return u.positions=r,u.indices=c,u.normals=f,u.uvs=y,u}function Me(p,t,e=null){const n=t.size,s=t.sizeX||n||1,i=t.sizeY||n||1,o=t.sizeZ||n||1;let r=t.m||1;r!==Math.floor(r)&&T.Warn("m not an integer only floor(m) used");let c=t.n||0;if(c!==Math.floor(c)&&T.Warn("n not an integer only floor(n) used"),c>r){const A=c;c=r,r=A,T.Warn("n > m therefore m and n swapped")}const f=new Y;f.build(r,c);const y=G.BuildGeodesicData(f),B=y.toGoldbergPolyhedronData(),x=new k(p,e);t.sideOrientation=q._GetDefaultSideOrientation(t.sideOrientation),x._originalBuilderSideOrientation=t.sideOrientation,Ie(t,B).applyToMesh(x,t.updatable),x.goldbergData.nbSharedFaces=y.sharedNodes,x.goldbergData.nbUnsharedFaces=y.poleNodes,x.goldbergData.adjacentFaces=y.adjacentFaces,x.goldbergData.nbFaces=x.goldbergData.nbSharedFaces+x.goldbergData.nbUnsharedFaces,x.goldbergData.nbFacesAtPole=(x.goldbergData.nbUnsharedFaces-12)/12;for(let A=0;A<y.vertex.length;A++)x.goldbergData.faceCenters.push(z.FromArray(y.vertex[A])),x.goldbergData.faceCenters[A].x*=s,x.goldbergData.faceCenters[A].y*=i,x.goldbergData.faceCenters[A].z*=o,x.goldbergData.faceColors.push(new K(1,1,1,1));for(let A=0;A<B.face.length;A++){const g=B.face[A],u=z.FromArray(B.vertex[g[0]]),D=z.FromArray(B.vertex[g[2]]),v=z.FromArray(B.vertex[g[1]]),C=D.subtract(u),l=v.subtract(u),a=z.Cross(l,C).normalize(),h=z.Cross(l,a).normalize();x.goldbergData.faceXaxis.push(l.normalize()),x.goldbergData.faceYaxis.push(a),x.goldbergData.faceZaxis.push(h)}return x}const E={CreateBox:J,CreateTiledBox:_,CreateSphere:$,CreateDisc:ee,CreateIcoSphere:te,CreateRibbon:se,CreateCylinder:ne,CreateTorus:oe,CreateTorusKnot:ae,CreateLineSystem:ie,CreateLines:re,CreateDashedLines:ce,ExtrudeShape:he,ExtrudeShapeCustom:le,CreateLathe:fe,CreateTiledPlane:de,CreatePlane:xe,CreateGround:Ae,CreateTiledGround:ue,CreateGroundFromHeightMap:ye,CreatePolygon:ge,ExtrudePolygon:Be,CreateTube:ve,CreatePolyhedron:X,CreateGeodesic:ze,CreateGoldberg:Me,CreateDecal:Oe,CreateCapsule:me,CreateText:pe};function L(p,t){return Math.random()*(t-p)+p}const P=document.getElementById("canvas");document.body.appendChild(P);const R=new De(P,!0);P.width=P.clientWidth*window.devicePixelRatio;P.height=P.clientHeight*window.devicePixelRatio;const Te=function(){const p=new be(R);new Ce("camera1",Math.PI/2,Math.PI/2-.6,40,new z(0,0,0),p).attachControl(P,!0);const e=E.CreatePlane("plane",{width:1e3,height:1e3},p);e.rotation.x=Math.PI/2;const n=new U("material",p);e.material=n;const s=10;for(let i=0;i<s;i++){const o=new we("light",new z(L(-5,5),L(1,4),L(-5,5)),p);o.range=5,o.diffuse.set(L(0,1),L(0,1),L(0,1));const r=E.CreateSphere("sphere",{segments:32,diameter:.6},p);r.position=o.position;const c=new U("material",p);c.disableLighting=!0,c.emissiveColor=new Ve(1,1,1),r.material=c}return Fe.LoadAssetContainerAsync("https://mdn.alipayobjects.com/oasis_be/afts/file/A*nceKQadLab8AAAAAAAAAAAAADkp5AQ/DamagedHelmet.glb","",p).then(i=>{i.addAllToScene(),i.meshes[0].position.y=1,n.maxSimultaneousLights=s,i.materials[0].maxSimultaneousLights=s}),p},Pe=Te();R.runRenderLoop(()=>{Pe.render()});window.addEventListener("resize",()=>{R.resize()});
